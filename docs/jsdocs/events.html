<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>

<head>
<title>UOX3 API and Event handling document</title>
<style></style>
<link rel="stylesheet" href="style.css" type="text/css">
</head>

<body>
<center>
	<h1>UOX3 Script Engine</h1>
	<h3>API and Event handling</h3>
</center>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="InRangeEvent">inRange</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function inRange( pCharacter, objInRange, objType )
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>objInRange comes into visible range of pCharacter.  pCharacter's script is activated
<tr><td valign="top" width="25%"><b>Notes</b><td>objType == 0 indicates objInRange is a character<br>objType == 1 indicates objInRange is an item

<tr><td valign="top" width="25%"><b>Purpose</b><td>Useful for when you want to do something when a certain thing comes into range.  You could yell out guards when a murderer comes into range, for instance, if you're in a guarded region.
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>function inRange( pCharacter, objInRange, objType )
{
	if( objType == 1 )	// An item came into range
	{
		pCharacter.DoStaticEffect( 0x376A, 9, 0, );	// Make some sparkles!
		if( objInRange.id == 0x1416 )	// Ooh, it's a purty piece of armour
		{
			pCharacter.EmoteMessage( &quot;*ooooooooooooo*" );
		}
	}
}
</pre>
</table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnAISliverEvent">onAISliver</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onAISliver( npcChar )
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>Every AI loop, during their AI slice
<tr><td valign="top" width="25%"><b>Notes</b><td>If script returns true/1, hard-coded AI will not run
<tr><td valign="top" width="25%"><b>Purpose</b><td>Great customization of AI on a per NPC basis.
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>
function onAISliver( tChar )
{
tChar.DoAction( 111 );
}
//The NPC tChar performs action 111 (dance-animation in 3D UO clients)
//on every NPC ai check, essentially looping the animation =)
</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnAttackEvent">onAttack</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onAttack( pAttacker, pDefender )
</pre><tr><td valign="top" width="25%"><b>When triggered</b>
<td>When pAttacker attacks pDefender (in each "round" of combat)
<tr><td valign="top" width="25%"><b>Notes</b><td>pAttacker's script is activated, and pDefender's onDefense event is fired<b><big>!</big></b>
<tr><td valign="top" width="25%"><b>Purpose</b><td>Flesh out the attacking code.
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>function onAttack( pAttacker, pDefender )<br>{<br>	pAttacker.TextMessage( &quot;Who lives in that castle?&quot; );<br>	pDefender.TextMessage( &quot;Help! Help! I'm being repressed!&quot; );<br>}
</pre>
</table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnBuyEvent">onBuy</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onBuy( pSock, Vendor )
</pre><tr><td valign="top" width="25%"><b>When triggered</b>
<td>Runs on NPC vendor before tradegump opens
<tr><td valign="top" width="25%"><b>Notes</b><td>Can be used to completely block access to a vendor based on criteria of one's choosing. Return false to block vendor trade gump, return true to allow it
<tr><td valign="top" width="25%"><b>Purpose</b><td>To allow more control over who can access NPC vendors.
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>
function onBuy( pSock, Vendor )
{
	// If player does not belong to the undead race, vendor wants nothing to do with him!
	if( pSock.currentChar.raceID != 11 )
	{
		Vendor.TextMessage( "Sorry, I don't sell to the likes of you!" );
		return false;
	}
	else
		return true;
}
</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnBuyFromVendorEvent">onBuyFromVendor</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onBuyFromVendor( pSock, Vendor, iBought )
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>Runs on item after player verifies purchase, but before purchase has gone through
<tr><td valign="top" width="25%"><b>Notes</b><td>Return false will block the sale from going through, without closing the menu.<br>Return true will make the purchase go through as normal.
<tr><td valign="top" width="25%"><b>Purpose</b><td>To allow restricting the purchase of specific items
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>
function onBuyFromVendor( pSock, Vendor, iBought )
{
	var pUser = pSock.currentChar;
	pUser.TextMessage( "I am buying an item ("+iBought.name+") from a vendor!" );
	Vendor.TextMessage( "I am selling an item!" );
	return true;
}
</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnBoughtFromVendorEvent">onBoughtFromVendor</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onBoughtFromVendor( pSock, Vendor, iBought )
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>Runs on item after purchase has gone through and item has reached player's backpack.
<tr><td valign="top" width="25%"><b>Notes</b><td>Used, amongst other things, for automatically turning pet-statues bought from animal-trainers into actual pets. Return false/0 or nothing to allow other scripts with event to also run. Return true/1 to prevent other scripts with event from running
<tr><td valign="top" width="25%"><b>Purpose</b><td>To allow manipulating the item that has been bought, immediately after it reaches the player's backpack.
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>
function onBoughtFromVendor( pSock, Vendor, iBought )
{
	var pUser = pSock.currentChar;
	pUser.TextMessage( "I bought an item ("+iBought.name+") from a vendor!" );
	Vendor.TextMessage( "I just sold an item to some random dude!" );
	return true;
}
</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnCallbackEvent">onCallback</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onCallback#( socket, target )
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>Triggered for player who selects a target initiated from a CustomTarget method
<tr><td valign="top" width="25%"><b>Notes</b><td># behind onCallback function-name is linked to the # used in the CustomTarget method that initiated the targeting cursor.
<tr><td valign="top" width="25%"><b>Purpose</b><td>To handle callbacks from targeting cursors
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>
function CommandRegistration()
{
	RegisterCommand( "disconnect", 2, true );
}
function command_DISCONNECT( socket, cmdString )
{
	var targMsg = GetDictionaryEntry( 196, socket.Language );
	<strong>socket.CustomTarget( 0, targMsg );</strong>
}
<strong>function onCallback0( socket, ourObj )</strong>
{
	if( !socket.GetWord( 1 ) && ourObj.isChar && ourObj.online )
	{
		var targSock = ourObj.socket;
		if( targSock && targSock != socket )
		{
			socket.SysMessage( GetDictionaryEntry( 1029, socket.Language ) );
			targSock.SysMessage( GetDictionaryEntry( 1030, targSock.Language ) );
			targSock.Disconnect();
		}
	}
}
</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnCharDoubleClick">onCharDoubleClick</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onCharDoubleClick( pUser, targChar )
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>When pUser double-clicks targChar.  Replaces any code behaviour that may exist
<tr><td valign="top" width="25%"><b>Notes</b><td>targChar's script is activated. Return false to prevent opening paperdoll, or return true to allow.
<tr><td valign="top" width="25%"><b>Purpose</b><td>To allow greater customization of doubleclicking on characters.
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>function onCharDoubleClick( pUser, targChar )
{
	targChar.TextMessage( "If you think you'll be allowed to see my paperdoll, think again!" );
	return false;
}</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnClick">onClick</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onClick( pUser, objClicked )
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>When pUser single-clicks objClicked.
<tr><td valign="top" width="25%"><b>Notes</b><td>objClicked's script is activated. Returning true/1 will replace any hard-coded behaviour that may exist (such as showing name of object clicked).<br>
If script is attached to a character, will also trigger when the AllNames macro is used.
<tr><td valign="top" width="25%"><b>Purpose</b><td>To allow greater customization on clicking on objects.
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>function onClick( pUser, objClicked )
{
	pUser.SysMessage("You have clicked on: "+objClicked.name );
	objClicked.TextMessage( "Zug, zug!" );
	return true;
}</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnCollideEvent">onCollide</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onCollide( targSock, pColliding, objCollidedWith )
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>When pColliding collides with objCollidedWith (stepped on basically)
<tr><td valign="top" width="25%"><b>Notes</b><td>objCollidedWith is only an item currently.  targSock is -1 if pColliding is an NPC. Return true to proceed with hard-coded handling of collision (and prevent other scripts with event from running), or false to continue checking additional scripts, or handle collision in script
<tr><td valign="top" width="25%"><b>Purpose</b><td>Replace of collision based triggers, increase teleporter abilities
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>function onCollide( trgSock, srcChar, trgItem )
{
	srcChar.Teleport( srcChar.x + 5, srcChar.y +5, srcChar.z, 0 );
	srcChar.EmoteMessage( "*Eegads, I am teleported!*" );
	//srcChar.DoStaticEffect( 0x376A, 9, 0, 0 );
	return false;
}</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnCombatStart">onCombatStart</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onCombatStart( pAttacker, pDefender )
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>When pAttacker attacks someone, pAttacker's script is triggered.
<tr><td valign="top" width="25%"><b>Notes</b><td>Return false to override existing hard-coded combat completely, return true to let hard-coded combat run it's course
<tr><td valign="top" width="25%"><b>Purpose</b><td>To allow overriding combat functionality
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>function onCombatStart( pAttacker, pDefender )
{
	pAttacker.TextMessage( "I'm attacking!" );
	pDefender.TextMessage( "I'm being attacked!" );
	return true;
}
</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnCombatEnd">onCombatEnd</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onCombatEnd( currChar, targChar )
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>When either currChar or targChar dies or goes out of range, the script is fired
<tr><td valign="top" width="25%"><b>Notes</b><td>return false to override what happens after combat ends, return true to allow hard-coded implementation to run
<tr><td valign="top" width="25%"><b>Purpose</b><td>Allow to override what happens when combat between two characters ends
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>function onCombatEnd( pDefender, pAttacker )
{
	if( currChar.health != 0 )
		currChar.TextMessage( "Whee! I survived combat!" );
	if( targChar.health != 0 )
		targChar.TextMessage( "Yay! I survived combat!" );
	return true;
}</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnCombatDamageCalc">onCombatDamageCalc</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onCombatDamageCalc( attacker, defender, getFightSkill, hitLoc )
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>Every time combat damage calculation occurs this event is fired
<tr><td valign="top" width="25%"><b>Notes</b><td>Return a damage value to override the combat calculation of the engine, or a negative value to use the engine
<tr><td valign="top" width="25%"><b>Purpose</b><td>Allow to override the combat damage calculation
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>function onCombatDamageCalc( pAttacker, pDefender, fightSkill, hitLoc )
{
	var baseDamage = pAttacker.attack;

	if( baseDamage == -1 )  // No damage if weapon breaks
		return 0;

	var damage = ApplyDamageBonuses( 1, pAttacker, pDefender, fightSkill, hitLoc, baseDamage );

	if( damage < 1 )
		return 0;

	// Apply defense modifiers based on armor, resistances etc
	damage = ApplyDefenseModifiers( 1, pAttacker, pDefender, fightSkill, hitLoc, damage, true);

	// If damage after defense modifiers is below 0, do a small random amount of damage still
	if( damage <= 0 )
		damage = RandomNumber( 0, 4 );

	// If defender is a player, damage is divided by this modifier from uox.ini
	if( !pDefender.npc )
		damage /= GetServerSetting( "NPCDAMAGERATE" );

	return damage;
}</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnCommand">onCommand</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onCommand( socket, cmdString )
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>When user tries to use a command that is neither hard-coded or has a custom command script.
<tr><td valign="top" width="25%"><b>Notes</b><td>Return true to indicate that the command has been handled by script, and prevent UOX3 from running other scripts with the event. Returning false will provide a default system message about unrecognized command.
<tr><td valign="top" width="25%"><b>Purpose</b><td>Quick and dirty way to setup custom commands.
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>function onCommand( socket, cmdString )
{
	socket.SysMessage( "You attempted to execute the command '', but no such command exists... yet!" );
	return true;
}</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnCreateDFNEvent">onCreateDFN</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onCreateDFN( objMade, objType )
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>When an item or char is created.  Note that for PCs, this is triggered when they first enter the world.
<tr><td valign="top" width="25%"><b>Notes</b><td>objType == 0 indicates an item<br>objType == 1 indicates a character
<tr><td valign="top" width="25%"><b>Purpose</b><td>Used for customization of players at creation, or tinkering items/chars when they're made.
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>function onCreate( objMade, objType )
{
	if( objType == 1 )
		objMade.SysMessage( "Welcome to Our Unique World(TM)!" );
}
// When this script is setup as "global id" (0) in JSE_FILEASSOCIATIONS.SCP,
// it will send the sysmessage to all NEW characters that enters the world.
</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnCreateTileEvent">onCreateTile</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onCreateTile( objMade, objType )
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>When a non-DFN based item is created.
<tr><td valign="top" width="25%"><b>Notes</b><td>objType == 0 indicates an item<br>objType == 1 indicates a character
<tr><td valign="top" width="25%"><b>Purpose</b><td>Used for customization of non-DFN based items at creation.
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>function onCreate( objMade, objType )
{
	objMade.name = "A renamed item";
}
// Only scripts using script-id 0 or ones assigned through harditems.dfn will work with this event.
</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnDamage">onDamage</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onDamage( damaged, attacker, damageValue );
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>When the char "damaged" gets damaged
<tr><td valign="top" width="25%"><b>Notes</b><td>The attacker can be a char or NULL
<tr><td valign="top" width="25%"><b>Purpose</b><td>Custom reactions to damage.
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>
function onDamage( damaged, attacker, damageValue )
{
	damaged.TextMessage( "Ouch, those "+damageValue+" points of damage hurt." );
}
</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnDeathEvent">onDeath</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onDeath( pDead );
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>When the player or NPC pDead dies
<tr><td valign="top" width="25%"><b>Notes</b>
  <td>Return false/0 or nothing to allow other scripts with event to also run. Return true/1 to prevent other scripts with event from running
<tr><td valign="top" width="25%"><b>Purpose</b><td>Custom death sequence.  Can do things like an explosion anim and what not here, for impact's sake.
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>
function onDeath( pDead )
{
	pDead.Teleport( 1000, 1000, 0 );
	return true;
}
</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnDeathBlowEvent">onDeathBlow</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onDeathBlow( pKilled, pKiller );
</pre>
<tr><td valign="top" width="25%"><b>When triggered</b>
<td>When a killing blow has been made
<tr><td valign="top" width="25%"><b>Notes</b>Return false to prevent deathblow from killing character, or true to allow it
<tr><td valign="top" width="25%"><b>Purpose</b>
<td>Custom reactions after a potential killing blow has been made
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>
function onDeathBlow( pDead, pKiller )
{
	pDead.health = pDead.health + 10;
	pDead.TextMessage( "But I'm not dead!" );
	return false;
}</pre>
</table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnDecayEvent">onDecay</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onDecay( iDecaying )
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>When iDecaying decays
<tr><td valign="top" width="25%"><b>Notes</b><td><b><big>Return false/0 to prevent item from decaying, or true to follow through with hard-coded decay process</big></b>
<tr><td valign="top" width="25%"><b>Purpose</b><td>
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>
function onDecay( iDecaying )
{
	iDecaying.StaticEffect( 0x376A, 9, 6 );
	return false;
}
</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnDefenseEvent">onDefense</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onDefense( pAttacker, pDefender )
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>When pAttacker attacks pDefender (in each "round" of combat)
<tr><td valign="top" width="25%"><b>Notes</b><td>pDefender's script fires, pAttacker's onAttack event is also fired

<tr><td valign="top" width="25%"><b>Purpose</b><td>Flesh out the attacking code.
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>function onDefense( pAttacker, pDefender )<br>{<br>	pAttacker.TextMessage( &quot;Who lives in that castle?&quot; );<br>	pDefender.TextMessage( &quot;Help! Help! I'm being repressed!&quot; );<br>}
</pre>
</table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnDeleteEvent">onDelete</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onDelete( objDestroyed, objType )
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>When an item or character is deleted
<tr><td valign="top" width="25%"><b>Notes</b><td>objType == 0 indicates an item<br>objType == 1 indicates a character
<tr><td valign="top" width="25%"><b>Purpose</b><td>
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>function onDelete( objDestroyed, objType )
{
	if( objType == 0 )
		ConsoleMessage( objDestroyed.name+" has been deleted from the world." );
}
</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnDispelEvent">onDispel</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onDispel( objDispelled, objType )
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>When objDispelled is dispelled.  objDispelled's script is activated.
<tr><td valign="top" width="25%"><b>Notes</b><td>objType == 0 indicates a character<br>objType == 1 indicates an item
<tr><td valign="top" width="25%"><b>Purpose</b><td>
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>
function onDispel( objDispelled, objType )
{
	ConsoleMessage( objDispelled.name+" has been dispelled." );
}
</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnDropEvent">onDrop</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onDrop( iDropped, pDropper )
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>When pDropper drops iDropped.
<tr><td valign="top" width="25%"><b>Notes</b><td>iDropped's script is activated.<br>Return Value Table:<br> false/0/nothing == bounce<br> true/1 == don't bounce, use code<br> 2 == don't bounce, don't use code
<tr><td valign="top" width="25%"><b>Purpose</b><td>Allowing control over dropping items from cursor
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>
function onDrop( iDropped, pDropper )
{
	var pSock = pDropper.socket;

	//Lets fetch the serial of the target-location
	var temp1 = pSock.GetByte( 10 );
	var temp2 = pSock.GetByte( 11 );
	var temp3 = pSock.GetByte( 12 );
	var temp4 = pSock.GetByte( 13 );

	//Check the value of Byte 10 to determine if the target is ground, character or container
	if( temp1 == 0 ) //Target is a character
	{
		var targetChar = CalcCharFromSer( temp1, temp2, temp3, temp4 )
		pDropper.TextMessage( "I've dropped this item on a character named "+targetChar.name+", let's bounce it back." );
		return false;
	}
	if( temp1 == 0xFF ) //Target is ground or another item
	{
		pDropper.TextMessage( "I've dropped this item on the ground or on another item." );
		return true;
	}
	if( temp1 <= 0x40 ) //Target is a container
	{
		var targetItem = CalcItemFromItem( temp1, temp2, temp3, temp4 );
		pDropper.TextMessage( "I've dropped this item in/on a container with ID "+targetItem.id+"." );
		return true;
	}
}
</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnDropItemOnItemEvent">onDropItemOnItem</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onDropItemOnItem( iDropped, cDropper, iDroppedOn )
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>When iDropped is dropped by cDropper on iDroppedOn
<tr><td valign="top" width="25%"><b>Notes</b><td>First iDropped's script is activated, and if it doesn't bounce, then same script is activated for iDroppedOn<br>Return Value Table:<br> false/0/nothing == bounce<br> true/1 == don't bounce, use code<br> 2 == don't bounce, don't use code
<tr><td valign="top" width="25%"><b>Purpose</b><td>
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>
function onDropItemOnItem( iDropped, cDropper, iDroppedOn )
{
	if( iDropped.id == 0x1f14 ) //If the item being dropped is a recall rune
	{
		if( iDroppedOn.id == 0x0efa ) //If the item being dropped on is a spellbook
		{
			cDropper.TextMessage("I am dropping "+iDropped.name+" on a "+iDroppedOn.name );
			return true;
		}
	}
	else
	{
		cDropper.TextMessage( "Generic error message!" );
		return false;
	}
}
</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnDropItemOnNPCEvent">onDropItemOnNpc</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onDropItemOnNpc( pDropper, pDroppedOn, iDropped )
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>When iDropped is dropped on pDroppedOn
<tr><td valign="top" width="25%"><b>Notes</b><td>First iDropped's script is activated, and if it doesn't bounce, then same script is activated for pDroppedOn<br>Return Value Table:<br> false/0/nothing == bounce<br> true/1 == don't bounce, use code<br> 2 == don't bounce, don't use code
<tr><td valign="top" width="25%"><b>Purpose</b><td>
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>
function onDropItemOnNpc( pDropper, pDroppedOn, iDropped )
{
	pDropper.TextMessage("Here, I offer you my this object as a gift of friendship.");
	pDroppedOn.TextMessage( "I reject your offering!" );
	iDropped.colour = 13;
	return false;
}
</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnEnterEvadeStateEvent">onEnterEvadeState</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onEnterEvadeState( mNPC, enemyChar )
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>When mNPC enters evasion state in combat due to being unable to reach enemyChar
<tr><td valign="top" width="25%"><b>Notes</b><td>As part of entering evasion state, the NPC's health will automatically be reset to maximum. Return false/0 or nothing to allow other scripts with event to also run. Return true/1 to prevent other scripts with event from running
<tr><td valign="top" width="25%"><b>Purpose</b><td>To allow custom reactions when NPCs enter evasion state. Could for instance have the NPC lash out in panic and destroy nearby dynamic, non-locked down and blocking items...
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>
function onEnterEvadeState( mNPC, enemyChar )
{
	mChar.TextMessage( "I've entered the Evade state! My HP will be replenished..." );
	enemyChar.TextMessage( "Oops, I caused the NPC to enter Evade state!" );
	return true;
}
</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnEnterRegionEvent">onEnterRegion</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onEnterRegion( pEntering, regionEntered )
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>When pEntering enters regionEntered
<tr><td valign="top" width="25%"><b>Notes</b><td>Region-scripts can be attached to regions through regions.dfn, using the script=# tag
<tr><td valign="top" width="25%"><b>Purpose</b><td>To allow custom reactions when players enter regions
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>
function onEnterRegion( pEntering, regionEntered )
{
	if( pEntering.raceID != 11 )
	{
		//sound the alarm! non-undead intruder to region
		//spawn undead guards
	}
}
</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnEntranceEvent">onEntrance</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onEntrance( iEntered, objEntering, objType )
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>When objEntering enters the multi object iEntered
<tr><td valign="top" width="25%"><b>Notes</b><td>objType == 0 indicates objEntering is a character<br>objType == 1 indicates objEntering is an item<br>iEntered's script is activated, objEntering's script is entered. Return false/0 or nothing to allow other scripts with event to also run. Return true/1 to prevent other scripts with event from running
<tr><td valign="top" width="25%"><b>Purpose</b><td>
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>
function onEntrance( iEntered, objEntering, objType )
{
	if( objType == 0 )
		objEntering.SysMessage("You have entered "+iEntered.name);
	return false;
}
</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnEquipEvent">onEquip</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onEquip( pEquipper, iEquipped )
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>When pEquipper has equipped iEquipped
<tr><td valign="top" width="25%"><b>Notes</b><td>iEquipped's script is activated. Return false/0 or nothing to allow other scripts with event to also run. Return true/1 to prevent other scripts with event from running
<tr><td valign="top" width="25%"><b>Purpose</b><td>To allow something to happen after a player has equipped item
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>
function onEquip( pEquipper, iEquipped )
{
	pEquipper.StaticEffect( 0x376A, 9, 6 );
	return false;
}
</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnEquipAttemptEvent">onEquipAttempt</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onEquipAttempt( pEquipper, iEquipped )
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>When pEquipper attempts to equip iEquipped
<tr><td valign="top" width="25%"><b>Notes</b><td>iEquipped's script is activated. Return false/0/nothing to reject attempt to equip iEquipped. Return true to allow equip code to continue running like normal (with additional equip checks done there).
<tr><td valign="top" width="25%"><b>Purpose</b><td>To allow overriding what happens when a player attempts to equip an item
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>
function onEquipAttempt( pEquipper, iEquipped )
{
	if( pEquipper.race == 0 )
	{
		pEquipper.TextMessage( "This item cannot be equipped by humans!" );
		return false;
	}
	return true;
}
</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnFall">onFall</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onFall( pFall, fallDistance )
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>When pFall falls fallDistance
<tr><td valign="top" width="25%"><b>Notes</b><td>pFall can be either an npc or pc, will only trigger if fallDistance is over 20, so it does not trigger whenever a character walks down steps/off small ledges/down hills, etc.<br>
<tr><td valign="top" width="25%"><b>Purpose</b><td>
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>
function onFall( pFall, fallDistance )
{
	if( fallDistance > 20 )
		pFall.SysMessage("Yikes! That was a long fall!");
}
</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnFlagChangeEvent">onFlagChange</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onFlagChange( pChanging, newStatus, oldStatus );
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>When a player's status changes.  IE innocent -> criminal, criminal->murderer, and so on.
<tr><td valign="top" width="25%"><b>Notes</b><td>May not fire instantly when the action is made. However, won't be long after change occurs will it be visible. Return false/0 or nothing to allow other scripts with event to also run. Return true/1 to prevent other scripts with event from running
<tr><td valign="top" width="25%"><b>Purpose</b><td>
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>
</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnGumpInputEvent">onGumpInput</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>
<tr><td valign="top" width="25%"><b>Notes</b><td>
<tr><td valign="top" width="25%"><b>Purpose</b><td>
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>
</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnGumpPressEntry">onGumpPress</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onGumpPress( pSock, pButton, gumpData )
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>When a player presses a button in a Gump.
<tr><td valign="top" width="25%"><b>Notes</b><td>pButton is the button-ids for normal gump-buttons, while gumpData handles radiobutton-ids, checkbox-ids, and text-entry-ids(and the text-entries).
<tr><td valign="top" width="25%"><b>Purpose</b><td>
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>
function onGumpPress( pSock, pButton, gumpData )
{
	var pUser = pSock.currentChar;
	switch(pButton)
	{
		case 0:
			// abort and do nothing
			break;
		case 1:
			var Text1 = gumpData.getEdit(0);
			pUser.SysMessage( "The first TextEntry was: "+Text1 );
			var Text2 = gumpData.getEdit(1);
			pUser.SysMessage( "The second TextEntry was: "+Text2 )
			var OtherButton = gumpData.getButton(0);
			switch(RadioButton)
			{
				case 0:
					pUser.SysMessage( "You selected RadioButton number: "+OtherButton );
					pUser.DoAction( 15 );
					break;
				case 1:
					pUser.SysMessage( "You selected RadioButton number: "+OtherButton );
					pUser.DoAction( 11 );
					break;
				case 2:
					pUser.SysMessage( "The Checkbox with ID "+OtherButton+" was checked." );
					pUser.DoAction( 18 );
					break;

			}
			break;
	}
}
</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnHouseCommand">onHouseCommand</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onHouseCommand( pSocket, iMulti, cmdID )
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>When a player speaks a house command while inside a house
<tr><td valign="top" width="25%"><b>Notes</b><td>cmdID is the ID of a triggerword uttered by the player. These triggerwords are defined client-side. Return true to prevent other scripts with event attached to same object from running
<tr><td valign="top" width="25%"><b>Purpose</b><td>To bring house command handling from hard code to JS engine, making it easier to adjust and extend the housing system in the future.
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>
function onHouseCommand( pSocket, iMulti, cmdID )
{
	if( ValidateObject( iMulti ) && iMulti.IsInMulti( pSocket.currentChar ))
	{
		switch( cmdID )
		{
			case 34: // Remove Thyself
				pSocket.CustomTarget( 0, "Who do you want to remove from your house?" );
				break;
			default:
				Console.Log( "Unhandled house command detected with cmdID: " + cmdID );
				return false;
		}
	}

	return true;
}</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnHungerChangeEvent">onHungerChange</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onHungerChange( pChanging, newStatus );
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>When a player's hunger level changes goes down.
<tr><td valign="top" width="25%"><b>Notes</b><td>If overridden, the normal hunger messages are not displayed. Return false to override hard-code and handle hunger in script, or return true to proceed with hard-code
<tr><td valign="top" width="25%"><b>Purpose</b><td>To allow customization of behaviour when a character's hunger level changes.  Could be used for wilding of pets, or for changing AI of monsters.
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>function onHungerChange( pChanging, newStatus )
<br>{
<br>	TextMessage( pChanging, "ooooo, I feel more hungry" );
<br>	if( newStatus == 0 )
<br>	{
<br>		TextMessage( pChanging, "I'm melting, I'm melting!" );
<br>	}
<br>	return true;
<br>}
</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnIterateEvent">onIterate</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onIterate( object )
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>On every object our iterator comes across.
<tr><td valign="top" width="25%"><b>Notes</b><td>if return value from script is true, it continues on running the loop<br>if return value is false, then the loop is halted
<tr><td valign="top" width="25%"><b>Purpose</b><td>To allow JS to loop through all world objects.
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>
function doStuff( socket, pUser )
{
	socket.SysMessage( "Killing all NPCs" );
	var numKilled = IterateOver( "CHARACTER" );
	socket.SysMessage( "Killed " + NumToString( numKilled ) + " NPCs " );
}

function onIterate( charCheck )
{
	if( !charCheck )
		return false;
	if( charCheck.npc )
		charCheck.Kill();
	return true;
}
</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnLeaveRegionEvent">onLeaveRegion</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onLeaveRegion( pLeaver, regionLeft )
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>When pLeaver leaves regionLeft
<tr><td valign="top" width="25%"><b>Notes</b><td>Region-scripts can be attached to regions through the script=# tag in regions.dfn
<tr><td valign="top" width="25%"><b>Purpose</b><td>To allow reactions when characters leave regions
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>
function onLeaveRegion( pLeaver, regionLeft )
{
	//if pLeaver is not allowed to leave the region
	//turn him into a criminal and spawn guards to go after him!
}
</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnLeavingEvent">onLeaving</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onLeaving( iLeft, objLeaving, objType )
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>when objLeaving leaves the multi object iLeft
<tr><td valign="top" width="25%"><b>Notes</b><td>objType == 0 indicates objLeaving is a character<br>objType == 1 indicates objLeaving is an item<br>iLeft's script is activated, objLeaving's script is activated. Return false/0 or nothing to allow other scripts with event to also run. Return true/1 to prevent other scripts with event from running
<tr><td valign="top" width="25%"><b>Purpose</b><td>
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>
function onLeaving( iLeft, objLeaving, objType )
{
	if( objType == 0 )
		objLeaving.SysMessage("You have left "+iLeft.name);
	return false;
}
</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnLightChangeEvent">onLightChange</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onLightChange( object, lightlevel )
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>Triggers for object (char or item) when lightlevel changes
<tr><td valign="top" width="25%"><b>Notes</b><td>Return true to prevent other scripts with same event from running, or return false/nothing to not affect the execution of other scripts with same event
<tr><td valign="top" width="25%"><b>Purpose</b><td>
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>
function onLightChange( object, lightlevel )
{
	(pseudo-code)
	<em>if( object && object is item )
	{
		if( object.id equals unlit lamppost )
		{
			if( lightlevel > 10 ) //high light levels = dark, low light levels = bright
			{
				object.id = lit lamppost
			}
		}
		else if( object.id equals lit lamppost )
		{
			if( lightlevel < 10 )
			{
				object.id = unlit lamppost
			}
		}
	}</em>
}
</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnLogin">onLogin</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onLogin( sockPlayer, pChar )
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>When pChar is logged in to the world
<tr><td valign="top" width="25%"><b>Notes</b><td>sockPlayer is never -1
<tr><td valign="top" width="25%"><b>Purpose</b><td>To allow customization of what happens when a player logs in.  Could pop up custom gumps, or do certain things (say everyone ALWAYS starts in one spot, no matter where they logged in.  Diabloesque hall logins).
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>function onLogin( sockPlayer, pChar )
<br>{
<br>	pChar.Teleport( 1000, 1000, 0, 0 );
<br>}
</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnLogout">onLogout</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onLogout( sockPlayer, pChar )
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>When pChar is logging out of the world
<tr><td valign="top" width="25%"><b>Notes</b><td>sockPlayer is never -1
<tr><td valign="top" width="25%"><b>Purpose</b><td>To allow customization of what happens when a player logs out.  Could pop up custom gumps, or do certain things to the character.
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>function onLogin( sockPlayer, pChar )
<br>{
<br>	sockPlayer.SysMessage ( "Farewell! Come back soon." );
<br>}
</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="onSpellCast">MagicSpellCast</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function MagicSpellCast( pUser, spellID )
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>When any spell is cast
<tr><td valign="top" width="25%"><b>Notes</b><td>Return value table:<br>-2: use NORMAL non-JS casting<br>-1: CANCEL normal spellcasting<br>0->inf: Spell delay in ms
<tr><td valign="top" width="25%"><b>Purpose</b><td>To allow overriding spellcasting on a spell-per-spell basis
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>
function onSpellCast( pUser, spellID )
{
	if( spellID == 18 )
	{
		pUser.CustomTarget( 0, "What do you want to target with your fireball?" );
			return -1;
	}
}
</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnPacketReceiveEvent">onPacketReceive</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onPacketReceive( socket, packetNum, subCommand )
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>When receiving a network packet
<tr><td valign="top" width="25%"><b>Notes</b><td>OVERLOADPACKETS needs to be enabled in UOX.INI and each specific packet script must be registered in jse_fileassociations.scp and registered with UOX3 via the PacketRegistration/RegisterPacket functions. Note that subCommand is currently not supported; can be left as 0. IMPORTANT: Once a packet has been registered this way, it needs to be handled in its entirety through the script, including any and all responses expected by the client. Not sending the correct response to a packet, or reading the wrong amount of bytes for the packet can result in unexpected behaviour in client/server.
<tr><td valign="top" width="25%"><b>Purpose</b><td>Similar to "packet-hooks" in other emulators - allows overriding the handling of incoming network packets without modifying the server source-code
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>
function PacketRegistration()
{
	RegisterPacket( [packetID], [subCommand] );
}

function onPacketReceive( pSocket, packetNum, subCommand )
{
	var cmd = pSocket.GetByte( 0 );
	if( cmd != packetNum )
		return;

	... // Read packet data here, using ReadBytes, GetByte, GetWord, GetDWord, GetSByte, GetSWord, GetSDWord and GetString socket methods
	return;
}
</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnPathfindEndEvent">onPathfindEnd</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onPathfindEnd( tChar, pathfindResult )
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>When NPC pathfinding after JS methods WalkTo()/RunTo() comes to an end
<tr><td valign="top" width="25%"><b>Notes</b><td>pathfindResult parameter returns -1 if pathfinding failed, 0 if pathfinding partially succeeded but final location was blocked by a character, and 1 if pathfinding succeeded and NPC reached target location
<tr><td valign="top" width="25%"><b>Purpose</b><td>Can be used to detect when NPC pathfinding comes to an end
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>
function onPathfindEnd( tChar, pathfindResult )
{
	if( ValidateObject( tChar ))
	{
		tChar.TextMessage( "Pathfinding ended! Result of pathfinding was... ");
		switch( pathfindResult )
		{
			case -1: // Pathfinding failed
				tChar.TextMessage( "...a failure! I couldn't move at all." );
				break;
			case 0: // Pathfinding partially succeeded, but didn't make it all the way to target destination
				tChar.TextMessage( "...a partial success! I made it part of the way there." );
				break;
			case 1: // Reached end of the path
				tChar.TextMessage( "...a success! I reached my target location." );
				break;
			default:
				tChar.TextMessage( "...a success? A failure? I have no idea. Result unknown!" );
				break;
		}

	}
}
</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnPickupEvent">onPickup</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onPickup( iPickedUp, pGrabber )
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>When pGrabber picks up iPickedUp
<tr><td valign="top" width="25%"><b>Notes</b><td>iPickedUp's script is activated.
<tr><td valign="top" width="25%"><b>Purpose</b><td>Allows control over whether characters are allowed to pickup certain items, or what happens when they do. Return false/0/nothing to prevent pickup, or true to allow.
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>function onPickup( iPickedUp, pGrabber )
{
	var pSock = pGrabber.socket;

	//Check the value of pSock.pickupSpot to determine where the item was picked up from
	switch( pSock.pickupSpot )
	{
		case 0: //nowhere
			pGrabber.TextMessage( "I picked up this item from... NOWHERE!" );
			break;
		case 1: //ground
			pGrabber.TextMessage( "I picked up this item from the ground." );
			break;
		case 2: //ownpack
			pGrabber.TextMessage( "I picked up this item from my own backpack." );
			break;
		case 3: //otherpack
			pGrabber.TextMessage( "I picked up this item from a container." );
			break;
		case 4: //paperdoll
			pGrabber.TextMessage( "I picked up this item from my paperdoll." );
			break;
		case 5: //bank
			pGrabber.TextMessage( "I picked up this item from my bank box." );
			break;
		default:
			pGrabber.TextMessage( "Error. Redo from Start." );
			break;
	}

	//Use return false to disallow the pickup and bounce item
	//return false;
}
</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnQuestGumpEvent">onQuestGump</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onQuestGump( pUser )
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>When Quest button in paperdoll is pressed
<tr><td valign="top" width="25%"><b>Notes</b><td>Return true to prevent other scripts with same event from running, or return false/nothing to not affect the execution of other scripts with same event
<tr><td valign="top" width="25%"><b>Purpose</b><td>To allow providing a response to players who click the Quest button in the paperdoll, for instance with a custom quest gump?
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>function onQuestGump( pUser )
{
	pUser.TextMessage( "I pressed the Quest button in paperdoll!" );
	return true;
}
</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnResurrectEvent">onResurrect</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onRessurect( pAlive );
</pre><tr><td valign="top" width="25%"><b>When triggered</b>
<td>When a player pAlive is being resurrected
<tr><td valign="top" width="25%"><b>Notes</b><td>Only applies to PCs. Return true to proceed with hard-coded resurrection, return false to prevent resurrection.<br>
<tr><td valign="top" width="25%"><b>Purpose</b>
<td>Control over what happens when a person comes to life once more
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>function onResurrect( pAlive )
{
	var ResAmount = pAlive.GetTag( "ResAmount" );
	if( ResAmount && ResAmount < 5 )
	{
		pAlive.SysMessage( "You still have some spirit left... have a good one!" );
		return true;
	}
	else
	{
		pAlive.SysMessage( "You've resurrected too many times already! Have fun in the gray world!" );
		return false;
	}
}<b></b></pre>
</table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="onScrollCast">onScrollCast</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onScrollCast( pUser, spellID )
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>When a spell is cast using a magic scroll
<tr><td valign="top" width="25%"><b>Notes</b><td>Return value table:<br>-2: use NORMAL non-JS casting<br>-1: CANCEL normal spellcasting<br>0->inf: Spell delay in ms
<tr><td valign="top" width="25%"><b>Purpose</b><td>To allow overriding spellcasting from magic scrolls
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>
function onScrollCast( pUser, spellID )
{
	if( spellID == 18 )
	{
		pUser.TextMessage( "I'm casting a fireball from a fireball-scroll!" );
		return -1;
	}
}
</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnSellEvent">onSell</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onSell( pSock, Vendor )
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>Runs on vendor before tradegump opens.
<tr><td valign="top" width="25%"><b>Notes</b>Return false to prevent sale, or true to allow it.<td>
<tr><td valign="top" width="25%"><b>Purpose</b><td>To allow greater control over who can sell stuff to specific vendors.
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>
function onSell( pSock, Vendor )
{
	// If player does not belong to the undead race, vendor wants nothing to do with him!
	if( pSock.currentChar.raceID != 11 )
	{
		Vendor.TextMessage( "RIGHT! As if I would buy from you..." );
		return false;
	}
	else
		return true;
}
</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnSellToVendorEvent">onSellToVendor</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onSellToVendor( pSock, Vendor, iSold )
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>Runs on item after player verifies sale, but before sale actually goes through.
<tr><td valign="top" width="25%"><b>Notes</b><td>Return false will block the sale from going through, without closing the menu.<br>Return true will make the sale go through as normal.
<tr><td valign="top" width="25%"><b>Purpose</b><td>To allow greater control over the selling of specific items to vendors
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>
function onSellToVendor( pSock, Vendor, iSold )
{
	var pUser = pSock.currentChar;
	pUser.TextMessage( "I am selling an item ("+iSold.name+") to a vendor!" );
	Vendor.TextMessage( "I am buying an item!" );
	return true;
}
</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnSoldToVendorEvent">onSoldToVendor</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onSoldToVendor( pSock, Vendor, iSold )
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>Runs on item after it has already been sold to the NPC vendor and has reached the NPC vendor's "bought"-backpack
<tr><td valign="top" width="25%"><b>Notes</b><td>If the item sold to the vendor stacks with items already there, the script will run on the entire stack, not just the one item specifically sold!. Return false/0 or nothing to allow other scripts with event to also run. Return true/1 to prevent other scripts with event from running
<tr><td valign="top" width="25%"><b>Purpose</b><td>To allow greater control over what happens after specific items have been sold to NPCs.
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>
function onSoldToVendor( pSock, Vendor, iSold )
{
	var pUser = pSock.currentChar;
	pUser.TextMessage( "I sold an item ("+iSold.name+") to a vendor!" );
	Vendor.TextMessage( "I just bought an item from some random dude!" );
	return true;
}
</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnSpecialMoveEvent">onSpecialMove</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onSpecialMove( pUser, abilityID )
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>When player toggles a special move from a combat book in client
<tr><td valign="top" width="25%"><b>Notes</b><td>Can be used in global scripts, or individual scripts attached to characters. Return true to prevent other scripts with same event from running, or return false/nothing to not affect the execution of other scripts with same event. See packet 0xBF, subCmd 0x19 in packet guides for details on special moves available, whose IDs range from 0x00 to 0x1D
<tr><td valign="top" width="25%"><b>Purpose</b><td>To allow implementation of special abilities used during combat (or otherwise) when players toggle these from client.
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>function onSpecialMove( pUser, abilityID )
{
	pUser.TextMessage( "I toggled a special move!" );
	return true;
}
</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnSkillEvent">onSkill</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onSkill( objUsing, skillUsed, objType )
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>when objUsing uses skill skillUsed.  objUsing's script is activated.
<tr><td valign="top" width="25%"><b>Notes</b><td>objType == 0 indicates objUsing is a character<br>objType == 1 indicates objUsing is an item
<tr><td valign="top" width="25%"><b>Purpose</b><td>Complements the use of current skill code.  Fires before any existing usage code kicks in.
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>
function onSkill( objUsing, skillUsed, objType )
{
	switch( skillUsed )
	{
	case 0:
		objUsing.TextMessage("Time to do some alchemy work!");
		break;
	case 1:
		objUsing.TextMessage("Now using Anatomy skill!");
		break;
	case 2:
		objUsing.TextMessage("Animal Lore usage Enabled!");
		break;
	//case etc.:
	}
}
</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnSkillChangeEvent">onSkillChange</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onSkillChange( pPlayer, skill )
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>This is fired if onSkillLoss isn't defined for skill loss, or onSkillGain isn't defined for skill gain.
<tr><td valign="top" width="25%"><b>Notes</b><td>
<tr><td valign="top" width="25%"><b>Purpose</b><td>Allows you to take action when your skill level changes
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>function onSkillChange( pPlayer, skill )
{
	pPlayer.TextMessage( pPlayer, "Oh dear, my skill's changed" );
}
</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="onSkillCheck">onSkillCheck</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onSkillCheck( pUser, skillID, lowSkill, highSkill )
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>Triggers for character with event attached when a skillcheck is performed
<tr><td valign="top" width="25%"><b>Notes</b><td>Runs just prior to skillcheck. Returning true will allow skillcheck to take place, but will also prevent any other scripts with same event from running.
<tr><td valign="top" width="25%"><b>Purpose</b><td>For taking additional action when skillchecks are performed.
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>function onSkillCheck( pUser, skillID, lowSkill, highSkill )
{
	pUser.TextMessage( "A skillcheck is being done for skill with ID " + skillID + "!" );
	return true;
}
</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnSkillGainEvent">onSkillGain</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onSkillGain( pPlayer, skill )
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>when pPlayer gains in skill skill
<tr><td valign="top" width="25%"><b>Notes</b><td>
<tr><td valign="top" width="25%"><b>Purpose</b><td>For taking actions when you gain skill.
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>function onSkillGain( pPlayer, skill )
{
	pPlayer.TextMessage("Wheee! I've gained some skill!");
}
</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnSkillLossEvent">onSkillLoss</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onSkillLoss( pPlayer, skill )
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>When pPlayer loses in skill skill
<tr><td valign="top" width="25%"><b>Notes</b><td>
<tr><td valign="top" width="25%"><b>Purpose</b><td>For doing something when you lose skill
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>function onSkillLoss( pPlayer, skill )
{
	pPlayer.TextMessage( "Oh no, I've lost skill!" );
}
</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnSkillGump">onSkillGump</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onSkillGump( pUser )
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>When pUser tries opening the skill-gump
<tr><td valign="top" width="25%"><b>Notes</b><td>
<tr><td valign="top" width="25%"><b>Purpose</b><td>For overriding the client's request to open the default skillgump. Return false to prevent opening default skillgump, or true to allow.
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>function onSkillGump( pUser )
{
	pUser.SysMessage( "Overriding default skillgump, opening custom one instead..." );
	// Insert custom skillgump here!
}
</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnSpellGainEvent">onSpellGain</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onSpellGain( spellBook, spellNum )
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>Triggered for spellbooks when spells are added to them
<tr><td valign="top" width="25%"><b>Notes</b><td>Returning false or nothing will prevent spell from being added to spellbook, while returning true will allow it.
<tr><td valign="top" width="25%"><b>Purpose</b><td>To allow overriding what happens when spells are added to spellbooks?
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>function onSpellGain( spellBook, spellNum )
{
	// Run a custom check here
	return true;
}
</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnSpellLossEvent">onSpellLoss</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onSpellLoss( spellBook, spellNum )
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>Triggered for spellbooks when spells are removed from them
<tr><td valign="top" width="25%"><b>Notes</b><td>Returning false will prevent spell from being removed from spellbook, while returning true will allow it.
<tr><td valign="top" width="25%"><b>Purpose</b><td>To allow overriding what happens when spells are removed from spellbooks?
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>function onSpellLoss( spellBook, spellNum )
{
	// Run a custom check here
	return true;
}
</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnSnoopedEvent">onSnooped</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onSnooped( pSnooped, pSnooping, bSuccess );
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>When pSnooping snoops into pSnooped's pack.
<tr><td valign="top" width="25%"><b>Notes</b><td>If overridden by returning true, internal behaviour not executed.  IE no calling for guards, no messages sent to snooper or snooped. bSuccess is true if successfully snooped, or false if not
<tr><td valign="top" width="25%"><b>Purpose</b><td>To allow for behavioural change on snooping behaviour.
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>function onSnooped( pSnooped, pSnooping, bSuccess )
{
	pSnooped.TextMessage( &quot;Oi! You! Stop snooping!" );
}
</pre>
</table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnSnoopAttemptEvent">onSnoopAttempt</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onSnoopAttempt( pSnooped, pSnooping );
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>When pSnooping attempts to snoop into pSnooped's pack.
<tr><td valign="top" width="25%"><b>Notes</b><td>Return false or nothing to prevent hard-code and other snooping-related events from running. Return true to allow hard-code and other snooping-events to run
<tr><td valign="top" width="25%"><b>Purpose</b><td>To allow for custom behaviour when players attempt to snoop into other characters' backpacks
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>function onSnoopAttempt( pSnooped, pSnooping )
{
	pSnooping.SysMessage( "The target is protected and cannot be snooped!" );
	return true;
}
</pre>
</table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnSpeechEvent">onSpeech</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onSpeech( strSaid, pTalking, pTalkingTo )
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>When pTalking says strSaid to pTalkingTo. pTalkingTo's script is activated. Can also trigger for items with script and this event attached, if ITEMSDETECTSPEECH is enabled in UOX.INI.
<tr><td valign="top" width="25%"><b>Notes</b><td>
<tr><td valign="top" width="25%"><b>Purpose</b><td>Greatly improve the speech handling capabilities
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>function onSpeech( strSaid, pTalking, pTalkingTo )
{
	pTalkingTo.TextMessage( strSaid );
}
// This is a simple mimic NPC.  Everything that someone says to it is quoted back verbatim
</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnSpeechInputEvent">onSpeechInput</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onSpeechInput(pUser, pItem, pSpeech, pSpeechID)
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>When the SpeechInput method is executed
<tr><td valign="top" width="25%"><b>Notes</b><td>
<tr><td valign="top" width="25%"><b>Purpose</b><td>To allow action after speech-input has been requested.
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>
function onUseChecked( pUser, iUsed)
{
	pUser.SysMessage( "What do you want to rename this item to:" );
	pUser.SpeechInput(1, iUsed);
}

function onSpeechInput(pUser, iUsed, pSpeech, pSpeechID)
{
	if(pSpeech == null || pSpeech == " ")
	{
		pUser.SysMessage( "You didn't type anything!" );
		return;
	}
		switch(pSpeechID)
		{
	case 1:
		pUser.SysMessage( "You rename the item to: "+pSpeech );
		iUsed.name = pSpeech;
		break;
	}
}
</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="onSpellCast">onSpellCast</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onSpellCast( pUser, spellID )
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>When any spell is cast
<tr><td valign="top" width="25%"><b>Notes</b><td>Return value table:<br>-2: use NORMAL non-JS casting<br>-1: CANCEL normal spellcasting<br>0->inf: Spell delay in ms
<tr><td valign="top" width="25%"><b>Purpose</b><td>To allow overriding spellcasting on a spell-per-spell basis
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>
function onSpellCast( pUser, spellID )
{
	if( spellID == 18 )
	{
		pUser.CustomTarget( 0, "What do you want to target with your fireball?" );
			return -1;
	}
}
</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="onSpellTarget">onSpellTarget</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onSpellTarget( myTarget, pUser, spellID )
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>When targeting something/someone with a spell
<tr><td valign="top" width="25%"><b>Notes</b><td>myTarget can be both items and characters. Return false/0 or nothing to allow other scripts with event to also run. Return true/1 to prevent other scripts with event from running
<tr><td valign="top" width="25%"><b>Purpose</b><td>
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>
function onSpellTarget( myTarget, pUser, spellID )
{
	if( spellID == 18 )
	{
		myTarget.TextMessage( "AAAAAAaaaaaaa! I've been hit by a fireball!" );
	}
	return true;
}
</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="onSpellSuccess">onSpellSuccess</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onSpellSuccess( pUser, spellID )
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>When successfully castin a spell
<tr><td valign="top" width="25%"><b>Notes</b><td>Return false/0 or nothing to allow other scripts with event to also run. Return true/1 to prevent other scripts with event from running
<tr><td valign="top" width="25%"><b>Purpose</b><td>
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>
function onSpellSuccess( pUser, spellID )
{
	if( spellID == 18 )
	{
		pUser.TextMessage( "Yes! I managed to cast a fireball!" );
	}
	return true;
}
</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnStatChangeEvent">onStatChange</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onStatChange( pPlayer, stat )
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>If onStatLoss isn't defined, and stat went down, or if onStatGained isn't defined and stat went up
<tr><td valign="top" width="25%"><b>Notes</b><td>
<tr><td valign="top" width="25%"><b>Purpose</b><td>
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>
function onStatChange( pPlayer, stat )
{
	pPlayer.TextMessage("Whee my stats changed!");
}
</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnStatGainEvent">onStatGained</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onStatGained( pPlayer, stat )
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>When pPlayer gains in stat stat
<tr><td valign="top" width="25%"><b>Notes</b><td>
<tr><td valign="top" width="25%"><b>Purpose</b><td>For taking action when a person gains in a stat
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>
function onStatGained( pPlayer, stat )
{
	pPlayer.TextMessage("Whee I gained some stat!");
}
</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnStatLossEvent">onStatLoss</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onStatLoss( pPlayer, stat )
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>When pPlayer loses in stat stat
<tr><td valign="top" width="25%"><b>Notes</b><td>
<tr><td valign="top" width="25%"><b>Purpose</b><td>For taking action when a person loses in a stat
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>
function onStatLoss( pPlayer, stat )
{
	pPlayer.TextMessage("Awww I lost some stats.");
}
</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnStealEvent">onSteal</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onSteal( thief, objStolen, victim )
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>When objStolen is stolen from victim, objStolen's script is activated
<tr><td valign="top" width="25%"><b>Notes</b><td>Works, but gives a console error: <i>ERROR: Chars[-1] referenced is invalid. Crash averted!</i><br>
Return false, 0 or nothing to allow code to run like normal. Return true or 1 to prevent hard code from running, as well as the onStolenFrom event (theft failed?). Return 2 to prevent hard code from executing, but allow onStolenFrom event to run like normal (theft succeeded, but handled in script?)
<tr><td valign="top" width="25%"><b>Purpose</b><td>Specialization of stealing.
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>
function onSteal( thief, objStolen, victim )
{
	thief.SysMessage( "You attempt to steal the "+objStolen.name );
	victim.TextMessage( "Who does this hand in my pocket belong to???" );
	ConsoleMessage( objStolen.name+" has been attempted stolen!" );
	return false; // allow stealing code to run like normal
}
</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnStolenFromEvent">onStolenFrom</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onStolenFrom( pThief, pVictim, iStolen );
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>When the player pThief steals the item iStolen from the character pVictim
<tr><td valign="top" width="25%"><b>Notes</b><td>Return false/0/nothing to run hard-code (and other scripts) like normal. Return true/1 to prevent hard-code from running, as well as any other scripts with event.
<tr><td valign="top" width="25%"><b>Purpose</b><td>To allow for response when items are stolen from a player.
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>function onStolenFrom( pThief, pVictim, iStolen )
<br>{
<br>	TextMessage( pVictim, "Hey you, get your hands off my banana!" );
<br>	Attack( pVictim, pThief );
<br>	YellMessage( pVictim, "GUARDS!!!!!!!" );
return false;
<br>}
</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnSwingEvent">onSwing</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onSwing( iSwung, pSwinging, pSwingAt )
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>When pSwinging swings iSwung at pSwingAt.
<tr><td valign="top" width="25%"><b>Notes</b><td>Event can trigger for either pSwinging character or iSwung item, depending on which object script is attached to. Return false to prevent swing and subsequent combat (damage, etc) code from happening, or true to allow swing
<tr><td valign="top" width="25%"><b>Purpose</b><td>
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>
function onSwing( iSwung, pSwinging, pSwingAt )
{
	pSwinging.TextMessage( "Have at thee, knave!" );
	return true;
}
</pre>
<tr>
  <td valign="top">
  <td>
</table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnSystemSliceEvent">onSystemSlice</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>
<tr><td valign="top" width="25%"><b>Notes</b><td>
<tr><td valign="top" width="25%"><b>Purpose</b><td>
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>
</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnTalkEvent">onTalk</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onTalk( pTalking, strSaid )
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>When pTalking says strSaid.  pTalking's script is activated
<tr><td valign="top" width="25%"><b>Notes</b><td>Return false to prevent hard-code from running, or true to proceed with hard-coded handling
<tr><td valign="top" width="25%"><b>Purpose</b><td>Greatly improve the speech handling capabilities
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>function onTalk( myChar, mySpeech )
{
	if( mySpeech == "'dig")
		myChar.DoAction(11);
	else
		return true;
}
// This is a simple script that will make the character talking perform the digging animation upon saying "'dig".
// (Note: 'DIG won't be displayed as speech, since script intercepts the text before it is spoken out loud)
// If anything else is said, the script returns true so speech can proceed as normal.
</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnTempChangeEvent">onTempChange</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onTempChange( object, temperature )
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>Triggers for object (char/item) when temperature changes
<tr><td valign="top" width="25%"><b>Notes</b><td>
<tr><td valign="top" width="25%"><b>Purpose</b><td>To allow reactions for characters/items when temperature changes
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>
</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnTimerEvent">onTimer</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onTimer( tChar, timerID )
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>When tempeffect 40 (StartTimer) duration has elapsed for timer timerID
<tr><td valign="top" width="25%"><b>Notes</b><td>
<tr><td valign="top" width="25%"><b>Purpose</b><td>To be used for custom timer information for characters.
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>function onTimer( tChar, timerID )
<br>{
<br>	if( timerID == 0 )
<br>	{
<br>		DoStaticEffect( pCharacter, 0x376A, 9, 0, 0 );	// Make some sparkles!
<br>	}
<br>}
</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnTransferEvent">onTransfer</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onTransfer( iTransferred, pSrc, pTrg )
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>When pSrc transfers iTransferred to pTrg
<tr><td valign="top" width="25%"><b>Notes</b><td>iTransferred's script is activated<br><b><big>CURRENTLY BROKEN!!!</big></b>
<tr><td valign="top" width="25%"><b>Purpose</b><td>
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>
function onTransfer( iTransferred, pSrc, pTrg )
{
	pSrc.TextMessage("Whee I'm transferring this item to you, "+pTrg.name+"!");
	pTrg.TextMessage("Thank you, "+pSrc.name+"!");
}
</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnUnequipEvent">onUnequip</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onUnequip( pEquipper, iUnequipped )
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>When pEquipper has unequipped iUnequipped
<tr><td valign="top" width="25%"><b>Notes</b><td>iUnequipped's script is activated. Return false/0 or nothing to allow other scripts with event to also run. Return true/1 to prevent other scripts with event from running
<tr><td valign="top" width="25%"><b>Purpose</b><td>To allow something to happen when player has unequipped item
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>
function onUnequip( pUnequipper, iUnequipped )
{
	pUnequipper.StaticEffect( 0x376A, 9, 6 );
	return false;
}
</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnUnequipAttemptEvent">onUnequipAttempt</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onUnequipAttempt( pEquipper, iUnequipped )
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>When pEquipper attempts to unequip iUnequipped
<tr><td valign="top" width="25%"><b>Notes</b><td>iUnequipped's script is activated. Returning false/0/nothing will reject the attempt to unequip the item, while returning true will allow unequip code to run like normal (with additional checks being done there).
<tr><td valign="top" width="25%"><b>Purpose</b><td>To allow overriding what happens when player attempts to unequip an item
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>
function onUnequipAttempt( pUnequipper, iUnequipped )
{
	if( /* check if item is cursed */ )
	{
		pUnequipper.TextMessage( "The item is cursed! You cannot unequip it..." );
		return false;
	}
	return true;
}
</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnUnknownTriggerEvent">onUnknownTrigger</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>
<tr><td valign="top" width="25%"><b>Notes</b><td>
<tr><td valign="top" width="25%"><b>Purpose</b><td>
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>
</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnUseBandageMacroEvent">onUseBandageMacro</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onUseBandageMacro( pSock, targChar, iUsed )
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>When pSock uses iUsed on targChar.
<tr><td valign="top" width="25%"><b>Notes</b><td>This can be put in the global script (scriptID 0) to handle what should happen when a player attempts to use the Bandage Self macro in the client. Return true to prevent other scripts with event from also triggering at the same time.
<tr><td valign="top" width="25%"><b>Purpose</b><td>To allow greater control of bandage self macro
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>
function onUseBandageMacro( pSock, targChar, bandageItem )
{
	targChar.TextMessage( "#0" );
	if( pSock && bandageItem && bandageItem.amount >= 1 )
	{
		var pUser = pSock.currentChar;
		TriggerEvent( 4000, "onUseCheckedTriggered", pUser, targChar, bandageItem );
	}
	return true;
}

...then, in scriptID 4000 - skill\healing.js, add this at the top of the file:

function onUseCheckedTriggered( pUser, targChar, iUsed )
{
	pUser.TextMessage( "#1" );
	if( pUser && iUsed && iUsed.isItem )
	{
		pUser.TextMessage( "#2" );

		var socket = pUser.socket;
		if( socket )
		{
			pUser.TextMessage( "#3" );

			if( pUser.skillsused.healing || pUser.skillsused.veterinary )
			{
				pUser.TextMessage( "#4" );
				socket.SysMessage( "You are too busy to do that." );
			}
			else if( socket.GetTimer( 0 ) <= GetCurrentClock() )
			{
				pUser.TextMessage( "#5" );
				socket.tempObj = iUsed;
				socket.SetTimer( 0, 5000 );
				onCallback1( socket, targChar );
			}
			else
			{
				pUser.TextMessage( "#6" );
				socket.SysMessage( GetDictionaryEntry( 473, socket.Language ) );
			}
		}
	}
	return true;
}
</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnUseCheckedEvent">onUseChecked</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onUseChecked( pUser, iUsed )
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>When pUser uses iUsed.
<tr><td valign="top" width="25%"><b>Notes</b><td>if return value from script is true, it continues on executing with hard coded implementation<br>if return value is false, then no hard code is executed
<tr><td valign="top" width="25%"><b>Purpose</b><td>To allow greater customization on using items.
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>
function onUseChecked( pUser, iUsed )
{
	var trgSock = pUser.socket;
	if(pUser.InRange( iUsed, 8 ))
		pUser.OpenBank(trgSock);
	return false;
}
</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnUseUnCheckedEvent">onUseUnChecked</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onUseUnChecked( pUser, iUsed )
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>When pUser uses iUsed.
<tr><td valign="top" width="25%"><b>Notes</b><td>Unlike the onUseChecked event this one runs without any hard-coded checks.
<tr><td valign="top" width="25%"><b>Purpose</b><td>To allow greater customization on using items.
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>
function onUseUnChecked( pUser, iUsed )
{
	var trgSock = pUser.socket;
	if(pUser.InRange( iUsed, 8 ))
		pUser.OpenBank(trgSock);
	return false;
}
</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnVirtueGumpPressEvent">onVirtueGumpPress</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onVirtueGumpPress( mChar, tChar, buttonID )
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>When Virtue gumps are pressed?
<tr><td valign="top" width="25%"><b>Notes</b><td>Return true to prevent other scripts with same event from running, or return false/nothing to not affect the execution of other scripts with same event
<tr><td valign="top" width="25%"><b>Purpose</b><td>
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>
</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OnWeatherChangeEvent">onWeatherChange</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function onWeatherChange( object, weatherType )
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>Triggers for object (char/item) when weather changes
<tr><td valign="top" width="25%"><b>Notes</b><td>
<tr><td valign="top" width="25%"><b>Purpose</b><td>To allow reactions for characters/items when weather changes
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>
</pre></table>

<p>&nbsp;</p><table border="1" width="100%" cellspacing="0">
<tr><th colspan=2 bgcolor="maroon"><a name="OutOfRange">OutOfRange</a>
<tr><td valign="top" width="25%"><b>Prototype</b><td><pre>function OutOfRange( pChar, objVanish, objType )
</pre><tr><td valign="top" width="25%"><b>When triggered</b><td>When objVanish goes out of range of pChar
<tr><td valign="top" width="25%"><b>Notes</b><td>objType == 0 indicates objVanish is a character<br>objType == 1 indicates objVanish is an item
<tr><td valign="top" width="25%"><b>Purpose</b><td>To take actions based on when things go out of range.  For instance, if you ran out of range of your attacker, you might decide to automatically try and hide.
<tr><td valign="top" width="25%"><b>Example of Usage</b><td><pre>
</pre></table>

<center>
<font face="Tahoma,Arial,MS Sans Serif" size="1">Copyright 2000-2001 <a href="http://www.uox3.net">WWW.UOX3.NET</a> (Daniel Stratton/Matthew Randall)</font>
</center>

</body>